# 第一章
虽然很多存储器在物理上是独立的器件（通过总线与cpu相连），但cpu把它们看成一个统一的逻辑存储器——内存地址空间
- 汇编指令通过编译器被翻译成机器码
- 一个cpu有N根地址线，则说它的地址总线宽度为N，最多可寻址2^N个内存单元
- 地址总线的宽度决定了CPU的寻址能力
- 数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量
- 控制总线的宽度决定了CPU对系统中其他器件的控制能力（有多少根总线就有多少种控制）
# 第二章 寄存器
物理地址=段地址x16+偏移地址（8086CPU 16位）\
本质意义：基础地址+偏移地址=物理地址\
CS存放指令的段地址，IP存放指令的偏移地址
- 一个内存单元存放一个字节（8位）
- 在写一条汇编指令或一个寄存器的名称时不区分大小写
- 如果运算结果的位数超过了寄存器的位数，高位丢失，16位的寄存器被当作两个8位的寄存器存放数据时（进行8位运算），al位数不足时，溢出的数据不会存到ah，这时两个是相互独立的寄存器。
（但CPU并不真的丢弃这个进位值）
- 在进行数据传送或运算时，指令的两个操作对象的位数应当一致
- 一个X进制的数据左移1位，相当于乘以X
- CPU可以用不同的段地址和偏移地址形成同一个物理地址
- 段寄存器（提供段地址）：CS，DS，SS，ES
- CS和IP\
  CS为代码段寄存器，IP为指令指针寄存器，CS：IP（CSx16+IP）指向8086CPU要执行的下一条指令
- 修改CS、IP\
  jmp 段地址：偏移地址               (同时修改CS、IP)\
  jmp 某一合法寄存器                 (修改IP(IP=该寄存器值))
  ## Debug
  - R -查看，改变CPU寄存器的内容\
  r 寄存器名（修改寄存器内的值）
  - D -查看内存中的内容\
   d 段地址：偏移地址（查看该处内存的内容）\
   在进入Debug后直接使用单个d命令，会列出Debug预设的地址处的内容，在使用“d 段地址：偏移地址”后再用单个d会显示其后续的内容\
   d 段地址：起始偏移地址_结尾偏移地址（指定d命令的查看范围)
  - E -改写内存中的内容\
   e 起始地址（段地址：偏移地址） 数据_数据_数据....（数据可以是数值，可以是字符（用单引号引起来）或字符串（双引号））\
   用提问的方式改写：输入e 段地址：偏移地址后按Enter，之后可以输入数据再按空格键即为更改完成，如果不输数据直接按空格键即为不修改，按空格后即为处理完成，Debug会显示下一单元并提示修改，如果所以改写已经完毕，按Enter键结束E命令操作
  - U -将内存中的机器指令翻译成汇编指令\
   u 段地址：偏移地址
  - T -执行一条机器指令
  - A -以汇编指令的格式在内存中写入一条机器指令\
   按Enter表示结束，a  起始地址（段地址：偏移地址）表示开始
  - G -g 内存地址（执行到该地址前停下）
  - P -p （自动重复循环直到cx=0）
